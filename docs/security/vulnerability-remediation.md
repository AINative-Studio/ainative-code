# Vulnerability Remediation Plan

**Last Updated:** January 4, 2026
**Status:** Active Remediation
**Owner:** Security Engineering Team

## Executive Summary

This document tracks all identified security vulnerabilities and their remediation status. All issues are prioritized by severity and tracked to completion.

**Current Status:**
- Critical: 0
- High: 1 (In Progress)
- Medium: 4 (Planned)
- Low: 138 (Backlog)

---

## High Priority Vulnerabilities

### VUL-001: HTTP Server Missing ReadHeaderTimeout (Slowloris Protection)

**Severity:** HIGH
**Status:** üîß IN PROGRESS
**Discovered:** 2026-01-04
**Target Fix Date:** 2026-01-05

#### Description
HTTP servers are configured without `ReadHeaderTimeout`, making them vulnerable to Slowloris attacks where attackers send partial HTTP headers slowly to exhaust server resources.

#### Affected Components
- `internal/auth/oauth/client.go:201-204`
- Any other `http.Server` instances without timeout configuration

#### Impact
- Denial of Service (DoS)
- Resource exhaustion
- Service unavailability

#### Technical Details
```go
// VULNERABLE CODE
server := &http.Server{
    Addr:    addr,
    Handler: mux,
    // Missing: ReadHeaderTimeout
}
```

#### Remediation

**Fix Applied:**
```go
server := &http.Server{
    Addr:    addr,
    Handler: mux,

    // Slowloris protection
    ReadHeaderTimeout: 5 * time.Second,
    ReadTimeout:       10 * time.Second,
    WriteTimeout:      10 * time.Second,
    IdleTimeout:       120 * time.Second,
}
```

**Verification Steps:**
1. Scan codebase for all `http.Server` instantiations
2. Add timeout configuration to each instance
3. Test with slow header attack simulation
4. Verify legitimate requests still work
5. Update documentation

**Testing:**
```go
func TestSlowlorisProtection(t *testing.T) {
    server := startTestServer()
    defer server.Close()

    // Simulate slow header attack
    conn, err := net.Dial("tcp", server.Addr)
    require.NoError(t, err)
    defer conn.Close()

    // Send partial request slowly
    conn.Write([]byte("GET / HTTP/1.1\r\n"))
    time.Sleep(6 * time.Second) // Exceeds ReadHeaderTimeout

    // Server should close connection
    _, err = conn.Write([]byte("Host: example.com\r\n\r\n"))
    assert.Error(t, err, "Connection should be closed")
}
```

**Status:** Implemented (see security hardening PR)

---

## Medium Priority Vulnerabilities

### VUL-002: Rate Limiting Disabled by Default

**Severity:** MEDIUM
**Status:** üìã PLANNED
**Discovered:** 2026-01-04
**Target Fix Date:** 2026-01-12

#### Description
Rate limiting is implemented but disabled by default in production configuration, leaving the application vulnerable to brute force attacks and resource exhaustion.

#### Affected Components
- `internal/config/loader.go:361`
- Default configuration files

#### Impact
- Brute force attacks on authentication
- API abuse
- Resource exhaustion
- No protection against automated attacks

#### Current Configuration
```go
l.viper.SetDefault("performance.rate_limit.enabled", false)  // ‚ùå DISABLED
```

#### Remediation

**Required Changes:**
1. Enable rate limiting by default in production
2. Add per-endpoint rate limit configuration
3. Implement rate limit headers
4. Add 429 Too Many Requests responses
5. Set up monitoring and alerting

**Recommended Configuration:**
```yaml
# config/production.yaml
performance:
  rate_limit:
    enabled: true
    requests_per_minute: 60
    burst_size: 10
    time_window: "1m"

    # Per-endpoint overrides
    endpoints:
      "/api/v1/auth/login":
        requests_per_minute: 5
        burst_size: 2
      "/api/v1/llm/chat":
        requests_per_minute: 30
        burst_size: 5
```

**Implementation Checklist:**
- [ ] Update default config to enable rate limiting
- [ ] Add rate limit headers (X-RateLimit-*)
- [ ] Implement 429 response handling
- [ ] Add per-endpoint configuration
- [ ] Create monitoring dashboard
- [ ] Document rate limits in API docs
- [ ] Add integration tests

**Timeline:** Sprint 2 (Week of 2026-01-08)

---

### VUL-003: TLS Not Enforced by Default

**Severity:** MEDIUM
**Status:** üìã PLANNED
**Discovered:** 2026-01-04
**Target Fix Date:** 2026-01-15

#### Description
TLS is disabled by default, allowing insecure HTTP connections that expose data to man-in-the-middle attacks.

#### Affected Components
- `internal/config/loader.go:387`
- Production deployment configuration

#### Impact
- Data transmitted in plaintext
- Susceptible to eavesdropping
- Man-in-the-middle attacks
- Session hijacking

#### Current Configuration
```go
l.viper.SetDefault("security.tls_enabled", false)  // ‚ùå INSECURE
```

#### Remediation

**Required Changes:**
1. Enable TLS by default in production
2. Add HTTPS enforcement middleware
3. Implement HSTS headers
4. Add HTTP to HTTPS redirect
5. Configure minimum TLS version (1.2+)

**Implementation:**
```go
// TLS Configuration
func NewProductionTLSConfig() *tls.Config {
    return &tls.Config{
        MinVersion: tls.VersionTLS12,
        CipherSuites: []uint16{
            tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
            tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
            tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
            tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
        },
        PreferServerCipherSuites: true,
        CurvePreferences: []tls.CurveID{
            tls.CurveP256,
            tls.X25519,
        },
    }
}

// HTTPS Enforcement Middleware
func HTTPSEnforcement(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        if r.TLS == nil {
            target := "https://" + r.Host + r.URL.RequestURI()
            http.Redirect(w, r, target, http.StatusMovedPermanently)
            return
        }

        // Add HSTS header
        w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")

        next.ServeHTTP(w, r)
    })
}
```

**Implementation Checklist:**
- [ ] Create TLS configuration helper
- [ ] Implement HTTPS enforcement middleware
- [ ] Add HSTS headers
- [ ] Configure automatic cert renewal (Let's Encrypt)
- [ ] Update deployment documentation
- [ ] Test certificate validation
- [ ] Add TLS version testing

**Timeline:** Sprint 2 (Week of 2026-01-08)

---

### VUL-004: Missing Rate Limit Headers

**Severity:** MEDIUM
**Status:** üìã PLANNED
**Discovered:** 2026-01-04
**Target Fix Date:** 2026-01-12

#### Description
Rate limiting middleware doesn't return standard rate limit headers, making it difficult for API clients to handle rate limits gracefully.

#### Affected Components
- `internal/middleware/rate_limiter.go`

#### Impact
- Poor API client experience
- Difficult to implement retry logic
- Unclear when rate limit resets

#### Required Headers
- `X-RateLimit-Limit`: Maximum requests allowed
- `X-RateLimit-Remaining`: Requests remaining
- `X-RateLimit-Reset`: Unix timestamp when limit resets
- `Retry-After`: Seconds until next request allowed (on 429)

#### Remediation

**Implementation:**
```go
func RateLimitMiddleware(limiter *ratelimit.Limiter) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            identifier := getUserIdentifier(r)

            // Check rate limit
            state := limiter.Check(identifier)

            // Add headers
            w.Header().Set("X-RateLimit-Limit", fmt.Sprint(state.Limit))
            w.Header().Set("X-RateLimit-Remaining", fmt.Sprint(state.Remaining))
            w.Header().Set("X-RateLimit-Reset", fmt.Sprint(state.ResetTime.Unix()))

            if !state.Allowed {
                retryAfter := int(time.Until(state.ResetTime).Seconds())
                w.Header().Set("Retry-After", fmt.Sprint(retryAfter))

                w.WriteHeader(http.StatusTooManyRequests)
                json.NewEncoder(w).Encode(map[string]interface{}{
                    "error": "rate_limit_exceeded",
                    "message": "Too many requests",
                    "retry_after_seconds": retryAfter,
                    "reset_time": state.ResetTime.Format(time.RFC3339),
                })
                return
            }

            next.ServeHTTP(w, r)
        })
    }
}
```

**Implementation Checklist:**
- [ ] Update rate limiter to return state info
- [ ] Add header setting in middleware
- [ ] Implement 429 response body
- [ ] Add client retry logic examples
- [ ] Update API documentation
- [ ] Add integration tests

**Timeline:** Sprint 2 (Week of 2026-01-08)

---

### VUL-005: Path Traversal Potential in File Operations

**Severity:** MEDIUM
**Status:** üìã PLANNED
**Discovered:** 2026-01-04
**Target Fix Date:** 2026-01-15

#### Description
File operations in various components accept user-provided paths without comprehensive sanitization, potentially allowing path traversal attacks.

#### Affected Components
- `internal/config/resolver.go:275` (file path resolution)
- `internal/tools/builtin/*_file.go` (file operation tools)
- `internal/cmd/design_*.go` (design file operations)

#### Impact
- Unauthorized file access
- Reading sensitive files (e.g., /etc/passwd)
- Overwriting critical files
- Information disclosure

#### Remediation

**Create Centralized Path Sanitization:**
```go
// internal/security/pathsanitizer.go
package security

import (
    "fmt"
    "path/filepath"
    "strings"
)

type PathSanitizer struct {
    allowedDirs []string
    allowAbsolute bool
}

func NewPathSanitizer(allowedDirs []string, allowAbsolute bool) *PathSanitizer {
    return &PathSanitizer{
        allowedDirs: allowedDirs,
        allowAbsolute: allowAbsolute,
    }
}

func (ps *PathSanitizer) Sanitize(userPath string) (string, error) {
    // Clean the path (removes .., ., etc.)
    cleaned := filepath.Clean(userPath)

    // Check for absolute path if not allowed
    if filepath.IsAbs(cleaned) && !ps.allowAbsolute {
        return "", fmt.Errorf("absolute paths not allowed")
    }

    // Check for path traversal patterns
    if strings.Contains(cleaned, "..") {
        return "", fmt.Errorf("path traversal detected")
    }

    // If we have allowed directories, ensure path is within them
    if len(ps.allowedDirs) > 0 {
        var allowed bool
        var finalPath string

        for _, allowedDir := range ps.allowedDirs {
            testPath := filepath.Join(allowedDir, cleaned)
            if strings.HasPrefix(testPath, filepath.Clean(allowedDir)) {
                allowed = true
                finalPath = testPath
                break
            }
        }

        if !allowed {
            return "", fmt.Errorf("path outside allowed directories")
        }

        return finalPath, nil
    }

    return cleaned, nil
}

// ValidateFilePath validates a file path before use
func (ps *PathSanitizer) ValidateFilePath(userPath string) error {
    _, err := ps.Sanitize(userPath)
    return err
}

// SanitizeAndCheck sanitizes path and checks if file exists
func (ps *PathSanitizer) SanitizeAndCheck(userPath string) (string, error) {
    sanitized, err := ps.Sanitize(userPath)
    if err != nil {
        return "", err
    }

    // Check if file exists
    if _, err := os.Stat(sanitized); err != nil {
        if os.IsNotExist(err) {
            return "", fmt.Errorf("file does not exist: %s", sanitized)
        }
        return "", fmt.Errorf("cannot access file: %w", err)
    }

    return sanitized, nil
}
```

**Implementation Checklist:**
- [ ] Create pathsanitizer package
- [ ] Update config resolver to use sanitizer
- [ ] Update file tools to use sanitizer
- [ ] Update design commands to use sanitizer
- [ ] Add comprehensive tests
- [ ] Document path security requirements

**Timeline:** Sprint 3 (Week of 2026-01-15)

---

## Low Priority Issues (Informational)

### Gosec Low Severity Findings (138 issues)

**Categories:**
1. **Error Handling** (G104): Unchecked errors
2. **Weak Random** (G404): Using math/rand instead of crypto/rand
3. **File Permissions** (G302): File created with potentially insecure permissions
4. **Variable Shadowing** (G601): Implicit memory aliasing

**Status:** üìù BACKLOG
**Action:** Address during regular code maintenance and refactoring

**Remediation Strategy:**
1. Review errors in batches (10-20 per sprint)
2. Prioritize based on code criticality
3. Add linting rules to prevent recurrence
4. Update coding standards

---

## False Positives

### G101: Hardcoded Credentials in Error Codes

**Locations:**
- `internal/errors/errors.go:24-27`
- `internal/database/messages.sql.go:263-267`

**Reason:** These are error code constants (e.g., `ErrCodeAuthFailed`), not actual credentials.

**Action:** Added to gosec exclusions:
```go
// #nosec G101 -- False positive: error code constant, not a credential
const ErrCodeAuthFailed = "auth_failed"
```

### Gitleaks: Test API Keys

**Locations:**
- `tests/e2e/error_recovery_test.go`
- `tests/fixtures/config.yaml`

**Reason:** Intentional test fixtures with invalid API keys

**Action:** Added to `.gitleaksignore`

---

## Remediation Timeline

### Sprint 1 (Week of 2026-01-04) - CURRENT
- [x] Security audit completion
- [x] Documentation creation
- [ ] VUL-001: Add ReadHeaderTimeout (HIGH)
- [ ] Create security test suite skeleton

### Sprint 2 (Week of 2026-01-08)
- [ ] VUL-002: Enable rate limiting (MEDIUM)
- [ ] VUL-003: Enforce TLS/HTTPS (MEDIUM)
- [ ] VUL-004: Add rate limit headers (MEDIUM)
- [ ] Implement authentication security tests

### Sprint 3 (Week of 2026-01-15)
- [ ] VUL-005: Path sanitization (MEDIUM)
- [ ] Complete input validation tests
- [ ] Add command injection tests
- [ ] SQL injection test suite

### Sprint 4 (Week of 2026-01-22)
- [ ] Address 20 low-severity gosec findings
- [ ] Complete rate limiting tests
- [ ] Security documentation review
- [ ] Penetration testing

### Ongoing
- [ ] Monthly dependency updates
- [ ] Weekly security scans
- [ ] Quarterly security audits

---

## Testing Requirements

### Security Test Coverage Goals

**Minimum Requirements:**
- Authentication tests: 95% coverage
- Input validation tests: 90% coverage
- Path sanitization tests: 100% coverage
- Rate limiting tests: 90% coverage

**Test Types:**
1. Unit tests for security functions
2. Integration tests for security middleware
3. Fuzzing tests for input validation
4. Penetration tests (manual + automated)

---

## Metrics and KPIs

### Security Metrics

| Metric | Target | Current |
|--------|--------|---------|
| Critical Vulnerabilities | 0 | 0 ‚úÖ |
| High Vulnerabilities | 0 | 1 üîß |
| Medium Vulnerabilities | < 5 | 4 üìã |
| Time to Fix (High) | < 24h | TBD |
| Time to Fix (Medium) | < 7 days | TBD |
| Security Test Coverage | > 85% | 0% (new) |
| gosec Issues | < 50 | 162 üìà |

### Success Criteria

**Sprint 1 Success:**
- [ ] All HIGH vulnerabilities fixed
- [ ] Security documentation complete
- [ ] Test suite skeleton created

**Project Success:**
- [ ] All MEDIUM vulnerabilities fixed
- [ ] Security test coverage > 85%
- [ ] gosec issues < 50
- [ ] Automated security scanning in CI/CD
- [ ] Security monitoring and alerting active

---

## Review and Updates

**Review Schedule:**
- Weekly: Update remediation status
- Monthly: Review new vulnerabilities
- Quarterly: Comprehensive security audit

**Document Owner:** Security Engineering Team
**Last Review:** January 4, 2026
**Next Review:** January 11, 2026

---

## Appendix A: Remediation Commands

### Run Security Scans
```bash
# gosec scan
gosec -fmt=json -out=gosec-results.json ./...

# gitleaks scan
gitleaks detect --source . --report-path gitleaks-report.json

# Dependency vulnerability scan
govulncheck ./...

# Go module verification
go mod verify
go mod tidy
```

### Test Security Features
```bash
# Run security tests
go test ./tests/security/... -v

# Run with race detector
go test -race ./...

# Run with coverage
go test -coverprofile=security_coverage.out ./tests/security/...
go tool cover -html=security_coverage.out
```

### Deployment Checks
```bash
# Verify TLS configuration
openssl s_client -connect yourdomain.com:443 -tls1_2

# Test rate limiting
for i in {1..100}; do curl https://api.yourdomain.com/endpoint; done

# Check security headers
curl -I https://yourdomain.com
```

---

**Document Version:** 1.0
**Classification:** Internal Use Only
