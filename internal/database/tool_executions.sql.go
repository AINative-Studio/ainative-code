// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tool_executions.sql

package database

import (
	"context"
)

const createToolExecution = `-- name: CreateToolExecution :exec
INSERT INTO tool_executions (
    id, message_id, tool_name, input, output, status, error, started_at, completed_at, duration_ms, retry_count, metadata
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateToolExecutionParams struct {
	ID          string  `json:"id"`
	MessageID   string  `json:"message_id"`
	ToolName    string  `json:"tool_name"`
	Input       string  `json:"input"`
	Output      *string `json:"output"`
	Status      string  `json:"status"`
	Error       *string `json:"error"`
	StartedAt   string  `json:"started_at"`
	CompletedAt *string `json:"completed_at"`
	DurationMs  *int64  `json:"duration_ms"`
	RetryCount  int64   `json:"retry_count"`
	Metadata    *string `json:"metadata"`
}

func (q *Queries) CreateToolExecution(ctx context.Context, arg CreateToolExecutionParams) error {
	_, err := q.db.ExecContext(ctx, createToolExecution,
		arg.ID,
		arg.MessageID,
		arg.ToolName,
		arg.Input,
		arg.Output,
		arg.Status,
		arg.Error,
		arg.StartedAt,
		arg.CompletedAt,
		arg.DurationMs,
		arg.RetryCount,
		arg.Metadata,
	)
	return err
}

const deleteToolExecution = `-- name: DeleteToolExecution :exec
DELETE FROM tool_executions
WHERE id = ?
`

func (q *Queries) DeleteToolExecution(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteToolExecution, id)
	return err
}

const deleteToolExecutionsByMessage = `-- name: DeleteToolExecutionsByMessage :exec
DELETE FROM tool_executions
WHERE message_id = ?
`

func (q *Queries) DeleteToolExecutionsByMessage(ctx context.Context, messageID string) error {
	_, err := q.db.ExecContext(ctx, deleteToolExecutionsByMessage, messageID)
	return err
}

const getFailedToolExecutions = `-- name: GetFailedToolExecutions :many
SELECT id, message_id, tool_name, input, output, status, error, started_at, completed_at, duration_ms, retry_count, metadata
FROM tool_executions
WHERE status = 'failed'
ORDER BY started_at DESC
LIMIT ? OFFSET ?
`

type GetFailedToolExecutionsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) GetFailedToolExecutions(ctx context.Context, arg GetFailedToolExecutionsParams) ([]ToolExecution, error) {
	rows, err := q.db.QueryContext(ctx, getFailedToolExecutions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolExecution{}
	for rows.Next() {
		var i ToolExecution
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.Input,
			&i.Output,
			&i.Status,
			&i.Error,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.RetryCount,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingToolExecutions = `-- name: GetPendingToolExecutions :many
SELECT id, message_id, tool_name, input, output, status, error, started_at, completed_at, duration_ms, retry_count, metadata
FROM tool_executions
WHERE status IN ('pending', 'running')
ORDER BY started_at ASC
`

func (q *Queries) GetPendingToolExecutions(ctx context.Context) ([]ToolExecution, error) {
	rows, err := q.db.QueryContext(ctx, getPendingToolExecutions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolExecution{}
	for rows.Next() {
		var i ToolExecution
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.Input,
			&i.Output,
			&i.Status,
			&i.Error,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.RetryCount,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentToolExecutions = `-- name: GetRecentToolExecutions :many
SELECT id, message_id, tool_name, input, output, status, error, started_at, completed_at, duration_ms, retry_count, metadata
FROM tool_executions
ORDER BY started_at DESC
LIMIT ?
`

func (q *Queries) GetRecentToolExecutions(ctx context.Context, limit int64) ([]ToolExecution, error) {
	rows, err := q.db.QueryContext(ctx, getRecentToolExecutions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolExecution{}
	for rows.Next() {
		var i ToolExecution
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.Input,
			&i.Output,
			&i.Status,
			&i.Error,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.RetryCount,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToolExecution = `-- name: GetToolExecution :one
SELECT id, message_id, tool_name, input, output, status, error, started_at, completed_at, duration_ms, retry_count, metadata
FROM tool_executions
WHERE id = ?
`

func (q *Queries) GetToolExecution(ctx context.Context, id string) (ToolExecution, error) {
	row := q.db.QueryRowContext(ctx, getToolExecution, id)
	var i ToolExecution
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.ToolName,
		&i.Input,
		&i.Output,
		&i.Status,
		&i.Error,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DurationMs,
		&i.RetryCount,
		&i.Metadata,
	)
	return i, err
}

const getToolExecutionCount = `-- name: GetToolExecutionCount :one
SELECT COUNT(*) as count
FROM tool_executions
WHERE message_id = ?
`

func (q *Queries) GetToolExecutionCount(ctx context.Context, messageID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getToolExecutionCount, messageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getToolExecutionCountByStatus = `-- name: GetToolExecutionCountByStatus :one
SELECT COUNT(*) as count
FROM tool_executions
WHERE status = ?
`

func (q *Queries) GetToolExecutionCountByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getToolExecutionCountByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getToolExecutionStats = `-- name: GetToolExecutionStats :one
SELECT
    COUNT(*) as total_executions,
    COUNT(CASE WHEN status = 'success' THEN 1 END) as successful_executions,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_executions,
    COUNT(CASE WHEN status = 'timeout' THEN 1 END) as timeout_executions,
    AVG(CASE WHEN duration_ms IS NOT NULL THEN duration_ms END) as avg_duration_ms,
    MAX(duration_ms) as max_duration_ms,
    MIN(duration_ms) as min_duration_ms
FROM tool_executions
WHERE tool_name = ?
`

type GetToolExecutionStatsRow struct {
	TotalExecutions      int64       `json:"total_executions"`
	SuccessfulExecutions int64       `json:"successful_executions"`
	FailedExecutions     int64       `json:"failed_executions"`
	TimeoutExecutions    int64       `json:"timeout_executions"`
	AvgDurationMs        *float64    `json:"avg_duration_ms"`
	MaxDurationMs        interface{} `json:"max_duration_ms"`
	MinDurationMs        interface{} `json:"min_duration_ms"`
}

func (q *Queries) GetToolExecutionStats(ctx context.Context, toolName string) (GetToolExecutionStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getToolExecutionStats, toolName)
	var i GetToolExecutionStatsRow
	err := row.Scan(
		&i.TotalExecutions,
		&i.SuccessfulExecutions,
		&i.FailedExecutions,
		&i.TimeoutExecutions,
		&i.AvgDurationMs,
		&i.MaxDurationMs,
		&i.MinDurationMs,
	)
	return i, err
}

const getToolExecutionsByTimeRange = `-- name: GetToolExecutionsByTimeRange :many
SELECT id, message_id, tool_name, input, output, status, error, started_at, completed_at, duration_ms, retry_count, metadata
FROM tool_executions
WHERE started_at >= ? AND started_at <= ?
ORDER BY started_at DESC
`

type GetToolExecutionsByTimeRangeParams struct {
	StartedAt   string `json:"started_at"`
	StartedAt_2 string `json:"started_at_2"`
}

func (q *Queries) GetToolExecutionsByTimeRange(ctx context.Context, arg GetToolExecutionsByTimeRangeParams) ([]ToolExecution, error) {
	rows, err := q.db.QueryContext(ctx, getToolExecutionsByTimeRange, arg.StartedAt, arg.StartedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolExecution{}
	for rows.Next() {
		var i ToolExecution
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.Input,
			&i.Output,
			&i.Status,
			&i.Error,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.RetryCount,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToolUsageStats = `-- name: GetToolUsageStats :many
SELECT
    tool_name,
    COUNT(*) as total_uses,
    COUNT(CASE WHEN status = 'success' THEN 1 END) as successful_uses,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_uses,
    AVG(CASE WHEN duration_ms IS NOT NULL THEN duration_ms END) as avg_duration_ms
FROM tool_executions
GROUP BY tool_name
ORDER BY total_uses DESC
`

type GetToolUsageStatsRow struct {
	ToolName       string   `json:"tool_name"`
	TotalUses      int64    `json:"total_uses"`
	SuccessfulUses int64    `json:"successful_uses"`
	FailedUses     int64    `json:"failed_uses"`
	AvgDurationMs  *float64 `json:"avg_duration_ms"`
}

func (q *Queries) GetToolUsageStats(ctx context.Context) ([]GetToolUsageStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getToolUsageStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetToolUsageStatsRow{}
	for rows.Next() {
		var i GetToolUsageStatsRow
		if err := rows.Scan(
			&i.ToolName,
			&i.TotalUses,
			&i.SuccessfulUses,
			&i.FailedUses,
			&i.AvgDurationMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementRetryCount = `-- name: IncrementRetryCount :exec
UPDATE tool_executions
SET retry_count = retry_count + 1
WHERE id = ?
`

func (q *Queries) IncrementRetryCount(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, incrementRetryCount, id)
	return err
}

const listToolExecutionsByMessage = `-- name: ListToolExecutionsByMessage :many
SELECT id, message_id, tool_name, input, output, status, error, started_at, completed_at, duration_ms, retry_count, metadata
FROM tool_executions
WHERE message_id = ?
ORDER BY started_at ASC
`

func (q *Queries) ListToolExecutionsByMessage(ctx context.Context, messageID string) ([]ToolExecution, error) {
	rows, err := q.db.QueryContext(ctx, listToolExecutionsByMessage, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolExecution{}
	for rows.Next() {
		var i ToolExecution
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.Input,
			&i.Output,
			&i.Status,
			&i.Error,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.RetryCount,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listToolExecutionsByName = `-- name: ListToolExecutionsByName :many
SELECT id, message_id, tool_name, input, output, status, error, started_at, completed_at, duration_ms, retry_count, metadata
FROM tool_executions
WHERE tool_name = ?
ORDER BY started_at DESC
LIMIT ? OFFSET ?
`

type ListToolExecutionsByNameParams struct {
	ToolName string `json:"tool_name"`
	Limit    int64  `json:"limit"`
	Offset   int64  `json:"offset"`
}

func (q *Queries) ListToolExecutionsByName(ctx context.Context, arg ListToolExecutionsByNameParams) ([]ToolExecution, error) {
	rows, err := q.db.QueryContext(ctx, listToolExecutionsByName, arg.ToolName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolExecution{}
	for rows.Next() {
		var i ToolExecution
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.Input,
			&i.Output,
			&i.Status,
			&i.Error,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.RetryCount,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listToolExecutionsBySession = `-- name: ListToolExecutionsBySession :many
SELECT te.id, te.message_id, te.tool_name, te.input, te.output, te.status, te.error, te.started_at, te.completed_at, te.duration_ms, te.retry_count, te.metadata
FROM tool_executions te
INNER JOIN messages m ON te.message_id = m.id
WHERE m.session_id = ?
ORDER BY te.started_at DESC
LIMIT ? OFFSET ?
`

type ListToolExecutionsBySessionParams struct {
	SessionID string `json:"session_id"`
	Limit     int64  `json:"limit"`
	Offset    int64  `json:"offset"`
}

func (q *Queries) ListToolExecutionsBySession(ctx context.Context, arg ListToolExecutionsBySessionParams) ([]ToolExecution, error) {
	rows, err := q.db.QueryContext(ctx, listToolExecutionsBySession, arg.SessionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolExecution{}
	for rows.Next() {
		var i ToolExecution
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.Input,
			&i.Output,
			&i.Status,
			&i.Error,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.RetryCount,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listToolExecutionsByStatus = `-- name: ListToolExecutionsByStatus :many
SELECT id, message_id, tool_name, input, output, status, error, started_at, completed_at, duration_ms, retry_count, metadata
FROM tool_executions
WHERE status = ?
ORDER BY started_at DESC
LIMIT ? OFFSET ?
`

type ListToolExecutionsByStatusParams struct {
	Status string `json:"status"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) ListToolExecutionsByStatus(ctx context.Context, arg ListToolExecutionsByStatusParams) ([]ToolExecution, error) {
	rows, err := q.db.QueryContext(ctx, listToolExecutionsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolExecution{}
	for rows.Next() {
		var i ToolExecution
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ToolName,
			&i.Input,
			&i.Output,
			&i.Status,
			&i.Error,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.RetryCount,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateToolExecutionError = `-- name: UpdateToolExecutionError :exec
UPDATE tool_executions
SET error = ?,
    status = 'failed',
    completed_at = CURRENT_TIMESTAMP,
    duration_ms = ?
WHERE id = ?
`

type UpdateToolExecutionErrorParams struct {
	Error      *string `json:"error"`
	DurationMs *int64  `json:"duration_ms"`
	ID         string  `json:"id"`
}

func (q *Queries) UpdateToolExecutionError(ctx context.Context, arg UpdateToolExecutionErrorParams) error {
	_, err := q.db.ExecContext(ctx, updateToolExecutionError, arg.Error, arg.DurationMs, arg.ID)
	return err
}

const updateToolExecutionOutput = `-- name: UpdateToolExecutionOutput :exec
UPDATE tool_executions
SET output = ?,
    status = ?,
    completed_at = CURRENT_TIMESTAMP,
    duration_ms = ?
WHERE id = ?
`

type UpdateToolExecutionOutputParams struct {
	Output     *string `json:"output"`
	Status     string  `json:"status"`
	DurationMs *int64  `json:"duration_ms"`
	ID         string  `json:"id"`
}

func (q *Queries) UpdateToolExecutionOutput(ctx context.Context, arg UpdateToolExecutionOutputParams) error {
	_, err := q.db.ExecContext(ctx, updateToolExecutionOutput,
		arg.Output,
		arg.Status,
		arg.DurationMs,
		arg.ID,
	)
	return err
}

const updateToolExecutionStatus = `-- name: UpdateToolExecutionStatus :exec
UPDATE tool_executions
SET status = ?,
    completed_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateToolExecutionStatusParams struct {
	Status string `json:"status"`
	ID     string `json:"id"`
}

func (q *Queries) UpdateToolExecutionStatus(ctx context.Context, arg UpdateToolExecutionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateToolExecutionStatus, arg.Status, arg.ID)
	return err
}
